\documentclass[conference,compsoc]{IEEEtran}
% Some/most Computer Society conferences require the compsoc mode option,
% but others may want the standard conference format.
%
% If IEEEtran.cls has not been installed into the LaTeX system files,
% manually specify the path to it like:
% \documentclass[conference,compsoc]{../sty/IEEEtran}





% Some very useful LaTeX packages include:
% (uncomment the ones you want to load)


\ifCLASSOPTIONcompsoc
  % IEEE Computer Society needs nocompress option
  % requires cite.sty v4.0 or later (November 2003)
  \usepackage[nocompress]{cite}
\else
  % normal IEEE
  \usepackage{cite}
\fi


\usepackage{listings}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{url}
\usepackage{lstcoq}
\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}
\begin{document}
\title{Hope}

\author{Anonymous}

% make the title area
\maketitle

% As a general rule, do not put math, special symbols or citations
% in the abstract
\begin{abstract}
  Despite the recent growth of zero-knowledge succinct argument 
  of knowledge (ZkSNARK) in cryptocurrencies, 
  sigma protocol remains a popular choice in electronic voting to maintain privacy 
  and verifiability of elections and still used in prominent e-voting systems such as 
  Helios, Belenois, SwissPost, etc. However, 
  the existing implementations of sigma protocol have two 
  shortcomings: (i) the same code is written twice, once for the front-end (JavaScript)
  and once for the back-end (Python/OCaml/Java), which is time-consuming but more importantly error-prone, 
  and (ii) none of these implementations offer any security guarantees. 
  
  In this paper, we present a certified implementation of sigma protocol in the Coq proof assistant and
  prove our implementation is (special) sound, complete, and 
  (honest verifier) zero-knowledge. Moreover, 
  we compile our Coq formalisation to WebAssembly and Rust; 
  thereby solve the problem of writing the same code twice. 
  We demonstrate the applicability of our
  formalisation by encoding the sigma protcol implemented in 
  Helios, Belenois, and SwissPost voting systems. 
  Our long terms goal is to provide a verified cryptographic library that can be 
  readily used in privacy-preserving voting systems.
\end{abstract}

% no keywords




% For peer review papers, you can put extra information on the cover
% page as needed:
% \ifCLASSOPTIONpeerreview
% \begin{center} \bfseries EDICS Category: 3-BBND \end{center}
% \fi
%
% For peerreview papers, this IEEEtran command inserts a page break and
% creates the second title. It will be ignored for other modes.
\IEEEpeerreviewmaketitle



\iffalse
\section{How to pitch this paper and What is the unique selling point of our work?}
Our Coq formalisation can be used at front-end (WebAssembly code) and 
back-end (Rust). Contrary to the existing work, our formalisation
does not write the same code twice. But sigma protocol is arcane and has 
been formalised couple of times before so why another formalisation?
None of the formalisation has been able to extract the code to executable code 
and one that was able to do so did not reason about probabilities in an intuitive way.
Moreover, that work was just geared towards verifying a transcript rather than
constructing it. Also, recently ZKP community started a movement to 
formalise the sigma protocols. We also demonstrates the 
applicability of our formalisation by encoding Helios cryptographic protocols
in our formalisation. 



\textbf{We need to explain why formal verification is important in the context of voting systems.}

\begin{itemize}
  \item Explain zero-knowledge proofs (completeness, soundness, zero-knowledge)
  \item Explain sigma protocols (completeness, special-soundness, honest-verifier zero-knowledg) 
  and mention about the Schnorr protocol
  \item Our contribution
  \item Explain the Schnorr protocol
  \item Explain Parallel, And, Eq, Or, and NEQ relations (also explain that 
  most of the formalisation has worked on And and Or relations)
\end{itemize}

\fi




\section{Introduction}
Electronic voting offers convenience and efficiency in electoral processes, potentially improving 
accessibility for disabled voters, increasing participation among overseas voters, and lowering 
the costs associated with conducting elections. Moreover,
they can streamline the voting process, reduce administrative burdens, and enable 
faster tallying of results. However, the transition to electronic voting also brings significant 
challenges, particularly in ensuring the privacy and verifiability of the voting process. Therefore, 
privacy and verifiability are two crucial elements that a voting system must ensure to adhere with 
the principles of a free-and-fair election. In a paper-ballot election, privacy is maintained by 
ensuring that no identifying information is present on a ballot that links it to a particular voter, 
and verifiability is achieved through scrutineers closely observing various electoral processes, 
including the counting of ballots. In order to have a similar effect in electronic voting, encryption 
is employed to safeguard the privacy of voter choices, while publicly verifiable evidence 
(such as zero-knowledge proofs) allows voters and independent observers to verify the integrity of 
the voting process. However, no matter how advanced the cryptographic techniques, they are useless 
if their software implementation contains bugs.
In fact, due to a major cryptographic flaw that
could let someone change votes cast using Switzerland's online 
voting software without being detected  \cite{9152765}, the Swiss Federal Chancellery suspended electronic voting in 
2019. It only resumed in 2023 after getting feedbacks from academic 
community \cite{swiss_evoting_chronik} about various component used in 
the electronic voting software. However, it is not an isolated  
instance where bugs have been found in a voting software, e.g., 
Voatz \cite{255334} (used in West Virginia, USA election),
Democracy Live Online Voting System \cite{263858} 
(used in Delaware, West Virginia, and New Jersey, USA election), 
Moscow Internet Voting System \cite{10.1007/978-3-030-51280-4_3}
(used in Russia election), and iVote System \cite{10.1007/978-3-319-22270-7_3, 10.1145/3014812.3014837} 
(used in New South Wales, Australia election), etc. 
These unfortunate situations can largely be attributed to two factors: 
(i) closed source code (proprietary artifacts) because most of these bugs were 
discovered by researchers who inspected the code after they were made public, and 
(ii) software testing which is inadequate to rule out all the bugs 
from a software. Therefore, to avoid the situations like this, 
an electronic voting system must adhere to \textit{software independence}\cite{rivest2008notion}:
\begin{quote}
  A voting system is software-independent if an
  (undetected) change or error in its software cannot
  cause an undetectable change or error in an
  election outcome. 
\end{quote}
\noindent
Therefore, many electronic voting systems follow the principals 
of \textit{end-to-end verifiability}. End-to-end verifiability is 
defined as: 
\begin{itemize}
  \item Cast-as-intended: voters get proof that the electronic ballot accurately reflects their choices.
  \item Collected-as-cast: the election authority provides proof that the electronic ballots are received without tampering.
  \item Counted-as-collected: the election authority provides proof that the results are based on correctly counting all received ballots.
\end{itemize} 


\noindent 
Finally, voters or scrutineers inspect these proofs and accept or reject the election results based on 
the verification of these proofs. In practice, this means that during the execution of an election, 
electronic voting software generates data, and voters and scrutineers verify the conformity of 
this data using independently written computer programs. The rationale is that if there is 
any discrepancy in the electronic voting system, at least one scrutineer or voter would detect it.
It is important to note that end-to-end verifiability is a valuable feature because it 
allows for the verification of the election results by checking the proofs of correctness 
once the election has concluded. This ensures that the election process was conducted 
properly and that the results are accurate, but it is applied during or after the voting has taken place.
However, can we use it before an election?
The answer is yes; we use a formal language to express end-to-end verifiability, or parts of 
it, and develop various components of electronic voting 
software in this formal language. This process is called as  formal verification, or correct-by-construction,
and it ensures that the software always produces valid proofs, 
which are consistently accepted by voters and scrutineers. In other words, formal verification
can be employed to develop reliable electronic voting software.
In fact, formal verification has emerged as a promising solution 
to eliminate potential bugs from software, and in recent years it has been increasingly 
adopted in real-world software applications \cite{10.1145/1111037.1111042}, 
including cryptography \cite{8835346,10.1145/3133956.3134043,190894,10.1145/2701415,
10.1145/2660267.2660370,10.1145/3319535.3363211}.

In this paper, we present a certified implementation of sigma protocol --an efficient 
type of zero-knowledge proof-- and its Parallel, And, Eq, Or, and Neq compositions in 
the formal language of Coq proof assistant. 
We have formalised and analysed the interactive version of 
the Sigma protocol, but in practice it is not convenient due to the required interaction. 
Therefore, all Sigma protocol implementations use the Fiat-Shamir 
transformation \cite{10.5555/36664.36676} to make them non-interactive. This involves 
using a hash function to replace the randomness of the public-coin verifier, though 
some care is required \cite{10.1007/978-3-642-34961-4_38}.
To make our formalisation self-contained and independent of external libraries, we have 
encoded SHA-256 in Coq and proven its usual correctness properties. Additionally, we 
have implemented efficient prime field arithmetic procedures and the Schnorr group to 
ensure our library is concrete and executable. Finally, we extract WebAssembly and 
Rust code from our certified implementation, one of the novelties of our 
formalisation.


There are numerous implementations of sigma protocol in various languages, 
e.g., Helios is written in Python, Belenois is written in OCaml, and SwissPost is written in Java.
However, there are two main issues with these implementations: 
(i) the same code is written twice 
once for the front-end (JavaScript, TypeScript) and once for the back-end (Python, OCaml, or Java) and 
(ii) none of these implementations offer any formal guarantees about the correctness of the code.
Therefore, we use our formalisation to model the sigma protocol implemented in Helios, 
Belenois, and SwissPost voting systems to demonstrate the usablity of 
our library. Unlike Helios and SwissPost,
we write one implementation and extract WebAssembly (front-end) and Rust (back-end) (\textbf{using the MetaCoq library}).
Belenois is slightly different in this respect and uses Js\_of\_ocaml 
to compile the OCaml code into JavaScript so it has only one 
implementation written in OCaml; nonetheless it is not verified 
and offers no formal guarantees. To the best of our knowledge, 
this is the firstformal verification of sigma protocol that can be used at 
the front-end (WebAssembly code) and back-end (Rust code). 

\subsection{Outline}
The rest of the paper is organised as follows: in section \ref{sigma_protocol}
we explain sigma protocol and its security properties. 


\section{Sigma Protocol}\label{sigma_protocol}
Despite the recent growth and popularity of zero-knowledge succinct 
argument of knowledge (ZKSNARK), sigma protocol remains a
leading cryptographic proof system in privacy-preserving voting systems. 
Sigma protocol is used in Helios --a widely popular voting system-- \cite{adida2008helios}, 
Belenois --used in French elections for overseas 
voters\footnote{VVFE, used in French elections, is a derivative of (part of) Belenios and 
inherited all the zero-knowledge proofs from Belenois.}-- \cite{cortier2023french}, and 
SwissPost --used in Swiss elections for overseas voters-- voting 
systems \cite{10.1007/978-3-031-15911-4_4} (\textbf{Look for more examples}). 
Moreover, recently zero-knowledge proof community started a movement to standardise
the sigma protocol \cite{ZKProof}.
One of the main reasons for its popularity in privacy-preserving voting systems is its
well-understood security.  Other application of sigma protocol 
include identification schemes, (cite more work). 

%\textbf{Introduce here that sigma protocol is efficient and simple and all other details about sigma protocol.} 
Zero-knowledge proofs were first studied by Goldwasser, Micali, and Rackoff \cite{10.1145/22145.22178} and 
are possible for all problems in $NP$ \cite{10.1145/116825.116852}. Recall that $NP$ is the class of 
problems that have efficient verifiers; that is, for a given problem in the $NP$ class, there is 
a polynomial-time algorithm that can verify whether a given solution, or witness, to the problem is correct or not.
More formally, for a given $NP$-relation $R$ and a statement $x$, zero-knowledge proof allows a prover 
$P$ to convince a verifier $V$ that they posses a witness $w$ --polynomial in length of $x$-- such 
that ($x$, $w$) $\in$ $R$. To accomplish this, $P$ and $V$ engage in a 
interactive protocol and  at the end of the protocol $V$ either accepts or rejects the proofs.
\textit{Sigma protocol}, \textbf{shown in the figure }, is an efficient three move zero-knowledge proof where the 
verifier is assumed to be honest and characterised by completeness, (special) soundness, and 
(special honest-verifier) zero-knowledge. More formally: 
\begin{itemize}
  \item \textbf{Completeness:}
  when $P$ and $V$ follow the protocol, $V$ always accepts. 
  In other words, if $P$ knows $w$ for $x$ such that ($x$, $w$) $\in$ $R$,  
  then $P$ can successfully construct a proof $(a, c, r)$ that always passes the verification equation, 
  i.e., $V$ accepts. 

\item \textbf{Special soundness:}
there exists a polynomial-time extractor $E$ which given 
two accepting transcripts $(a, c, r)$ and $(a, c', r')$ for $x$, 
it can extract a witness $w$ such that $(x, w) \in R$. In other words, 
if $P$ does not know $w$ for $x$ then it cannot construct a proof 
(a; c; r) that will passes the verification check. 
\item \textbf{Special honest-verifier zero-knowledge proof:}
There exists a polynomial-time simulator $S$ that, for any 
$v \in L_R$ where $L_R = \{x  \mid (x, w) \in R\}$,
generates an accepting transcript $(a, c, r)$ 
without using the witness $w$. 
This transcript is indistinguishable from one produced by an 
honest conversation between $P$ and $V$ using $w$, 
satisfying $(v,w) \in R$.

\end{itemize}

\textbf{Draw a picture here of sigma protocol}







Sigma protocol was first defined by Ronald Cramer \cite{cramer1996modular} 
and the first efficient sigma protocol was introduced by Schnorr in \cite{schnorr1991efficient}. 
Eventhough there exists many sigma protocols, the Schnorr protocol is used extensively in privacy-preserving voting systems, e.g, Helios, Belenois, SwissPost, etc. Therefore, 
our formalisation is geared towards the Schnorr protocol. 
Moreover, we also formalise the composition of (i) $n$ \textit{Parallel} Schnorr, 
(i) $n$ \textit{And} Schnorr, (iii) $n$ \textit{Or} Schnorr, and (iv) $n$ \textit{Eq} Schnorr protocol. 
Ideally, given the abstraction of our formlisation (\textit{vector space}), we could have 
abstracted the sigma protocol and their composition in a generic way \cite{10.1007/978-3-642-02384-2_17},
but we decided to focus on the Schnorr protocol and its composition to ensure familiar APIs 
for e-voting in WebAssembly and Rust. We also formalise Okamoto protocol as a subprotocol 
for Neq composition (\textbf{Berry: does it sound okay?}). However, we have not seen 
much use of Neq in the privacy-preserving voting systems, at least in the existing voting systems. 




\section{The Coq Theorem Prover}
\textbf{FIXME:this seems too much of tutorial Coq so let me know your thoughts. We 
can explain MetaCoq here as well and the extraction to Rust and WebAssembly
so that it justifies this tutorial}
The Coq theorem prover \cite{the_coq_development_team} is a computer program that interacts with users, 
enabling them to encode mathematical definitions, express specifications (true statements) about 
these definitions, and formally prove that the definitions imply the specifications. 
A user first defines their mathematical object (definition) and then figure 
out some  true statements (specifications) about 
that object. Once the user has definition 
and specifications, they need to prove 
that the definition satisfies the specifications 
(proof writing). In general, amongst these three steps, 
the proof writing step is the most challenging and important step. 
During the proof writing, the user interacts with the Coq theorem prover 
via \emph{tactics}, a domain specific language 
to ease the proof writing. Even though the Coq theorem 
provides some amount of automation and proof 
search, most of the time it requires human assistance to finish the proof. 
It is one the most popular and robust theorem, and
one of reasons for its popularity is 
dependent types, that makes it possible to encode
any mathematical statement in its logic.
It has been used to verify many real world software projects and mathematical 
artefacts. For example, Coq has been used to 
formally verify CompCert \cite{10.1145/1111037.1111042}, 
a C compiler used by many companies\footnote{https://www.absint.com/partners.htm}, 
Fiat-Crypto \cite{8835346} 
used in BoringSSL --a cryptographic library used in Chrome, Android, 
and CloudFlare--, ConCert \cite{10.1145/3372885.3373829}, 
a smart contract certification framework, etc. \textbf{FIXME: More examples}



\subsubsection*{Definitions, Specifications, and Proofs}
In this section, we demonstrate how to encode definitions, write specifications,
and formally prove that definitions satisfy the specifications 
in the Coq theorem prover by an example of 
natural numbers (natural numbers is the set $\{0, 1, 2, 3, \dots \}$). 
The set of natural numbers $Nat$ is the set of elements defined by the 
following clauses:
\begin{itemize}
  \item \emph{Zero}, represents $0$, is in the set Nat ($Zero \in Nat$)
  \item if $n$ is in the set Nat, then \emph{Succ n}, represents $n + 1$, 
    is also in the set Nat (if $n \in Nat$, then $Succ \text{ }n \in Nat$)
\end{itemize}

\noindent 
This representation of natural numbers is called 
inductively defined set where the base case, or starting point,
is Zero (constant symbol), and if we have a natural number $n$, then we can 
get the next natural number by prefixing Succ (unary function symbol) to $n$.  
Using this encoding of natural numbers, we can represent 
$1$ by \emph{Succ Zero}, and $2$ by \emph{Succ (Succ Zero)}, 
and so on. We encode the set \emph{Nat} in Coq as inductively defined data type, 
shown in Listing \ref{ind_nat}, with 
two constructors: \emph{Zero} and \emph{Succ}. 
\begin{lstlisting}[frame=single, language=Coq, caption={Definition of Natural Number},
  label={ind_nat},captionpos=t, basicstyle=\ttfamily\footnotesize,
  abovecaptionskip=-\medskipamount]
Inductive Nat : Type := 
| Zero : Nat 
| Succ : Nat -> Nat.
\end{lstlisting}


With the definition of natural numbers at our disposal,
we can define addition, subtraction, multiplication, division, and 
many other mathematical functions on natural numbers in the Coq theorem prover. 
However, we only define the addition function,
shown in Listing \ref{add_fn}, to demonstrate the concept. 
In Coq, \emph{Fixpoint} is a keyword 
for defining function, followed by the name of the function (\emph{plus}), 
arguments (\emph{m} and \emph{n}), and the body (definition) of the function.
The body of plus shown in Listing \ref{add_fn} is Coq encoding of the 
following two clauses:
\begin{enumerate}
  \item plus Zero n = n 
  \item plus (Succ m) n = Succ (plus m n)
\end{enumerate}  

\noindent 
The first clause amounts to $0 + n = n$ and the second clause
amounts to $ (1 + m) + n = 1 + (m + n)$.


\begin{lstlisting}[frame=single, language=Coq, caption={Addition of two Natural Numbers},
  label={add_fn},captionpos=t, basicstyle=\ttfamily\footnotesize,
  abovecaptionskip=-\medskipamount]
Fixpoint plus (m n : Nat) :=
  match m with
  | Zero => n
  | Succ m' => Succ (plus m' n)
  end.

\end{lstlisting}


So far we have just definitions of natural numbers and addition on them.
Now, it is time to define some specification (true statement) about
the addition operation, on natural numbers. From mathematical 
literature, we know that the addition operation on natural
numbers is associative and commutative. For simplicity, we
prove that our definition of addition on natural numbers is commutative, shown in 
Listing \ref{plus_comm}, and it is precisely the \emph{specification} for 
our addition operation. 

\begin{lstlisting}[frame=single, language=Coq, caption={Addition is Commutative},
  label={plus_comm},captionpos=t, basicstyle=\ttfamily\footnotesize,
  abovecaptionskip=-\medskipamount]
Theorem plus_commutative : 
  forall n m, plus n m = plus m n. 
Proof.
  induction n.
  (* base case *)
  + intros m.
  (* proof terms omitted *)
  (* inductive case *)  
  + intros m.
    rewrite IHn.
    (* proof terms omitted *)
Qed.
  
\end{lstlisting}

In Coq, \emph{Theorem} is the keyword
to define a specification, followed by the name (\emph{plus\_comm}). 
It says that for any two arbitrary natural numbers $m$ and $n$, 
encoded as \texttt{forall n m}, adding $n$ and $m$ is the same
as adding $m$ and $n$, encoded as \texttt{plus n m = plus m n}.
To write a formal proof of this statement, we tell the Coq theorem 
prover that we want to use the tactic language by 
stating the keyword \emph{Proof}. After finishing the proof, 
we use the keyword \emph{Qed} to inform Coq that our proof is 
finished. The moment Coq sees \emph{Qed},
it ensures that the proof is complete and correct according to its 
underlying logic. If we try to use Qed without finishing the proof,
Coq will not let us do so. Therefore, once we have Qed for any 
specification, by just trusting the Coq theorem prover we can be 
sure that our proof is correct. However, at this point, 
the curious reader can argue that why should we trust 
Coq because it is a computer program, similar any other 
computer program? Trusting Coq hinges on two things: 
(i) the meta theory, \emph{Calculus of Inductive Construction},
of Coq \cite{thierry1988calculus}
and (ii) its OCaml implementation \cite{the_coq_development_team}.
The meta theory of Coq has been scrutinised for decades
by many mathematicians and so far it has withstood all 
the scrutiny. The OCaml implementation of Coq  has a very 
small kernel and has been inspected by many computer scientists. 
In addition, there is a recent effort to develop more 
rigorous implementation for Coq proof checking \cite{10.1145/3371076} \textbf{FIXME: this is the place 
to state that we are following this path of MetaCoq}.



The keywords \emph{induction, intros, rewrite}
are tactics that are used to prove the statement that addition 
on natural numbers is commutative. 
The proof written between 
the keywords \emph{Proof} and \emph{Qed} amounts to the following: 
\begin{itemize}
  \item Base case: when $n$ is Zero, we need to prove that \texttt{plus Zero m = plus m Zero}
  \item Inductive case: when $n$ is Succ, we assume \texttt{plus m n = plus n m} 
      and we need to prove \texttt{plus (Succ m) n = plus n (Succ m)}
\end{itemize}  
\noindent
It is called proof by induction, and 
tactics are used to make the complicated 
process of proof writing easy.







\subsection{Schnorr Protocol Coq Encoding}

  We briefly explain the Schnorr protocol, which is very similar to figure \textbf{refer here to sigma protocol picture}.
  Given some public input $(G, g, q, h)$ where $G$
  is a cyclic group of prime order $q$, $g$ and $h$ are two 
  generators of the group $G$, the prover claims that they know a
  witness $w$ for the statement $h = g^w$; the existence of such
  a $w$ is immediate because $g$ generates the group. However,
  does the prover know the witness $w$? In order to convince the
  verifier, the prover and the verifier do the following:
  \begin{itemize}
    \item the prover picks a random number $u$, computes $a = g^u$,
    and sends $a$ to the verifier.
    \item the verifier picks a random challenge $c$ and sends it to
    the prover
    \item the prover computes $r = u + c * w$ and sends $r$ to the
    verifier
  \end{itemize}

The verifier accepts the transcript $(a, c, r)$ if $g^r = a * h^c$, otherwise rejects. We can prove that 
this protocol has completeness, special soundness, and special honest-verifier 
zero-knowledge proof. 


\begin{itemize}
  \item completeness: when $P$ and $V$ both follows the protocol, $V$ accepts the proof, i.e., 
  the verification equation checks out. We can see by algebraic simplification that it is the case.
    \begin{align*}
      g^r = g^{u + c * w} = g^u * (g^w)^c = a * h^c
    \end{align*}
  \item special soundness: from two accepting 
  conversations $(a, c, r)$ and $(a, c', r')$ where $c \neq c'$,
  a polynomial-time extractor can extract a witness $w$, 
  which is equal to $(r - r') * (c - c')^{-1}$, 
  such that $g^w = h$. By means of algebraic simplification, 
  we can see that it is the case.  
  \begin{align}
    g^r = a * h^c = g^u * (g^w)^c = g^{u + w * c}  \\
    g^{r'} = a * h^{c'} = g^u * (g^w)^{c'} = g^{u + w * c'}
  \end{align}
  Diving the expression (1) with (2), we get
  \begin{align*}
    g^{(r-r')} = g^{w * (c - c')}
  \end{align*}
  and multiplying both sides by $(c - c')^{-1}$ we 
  get 
  \begin{align*}
    g^{(r-r') * (c - c')^{-1}} = g^{w}
  \end{align*}

  \item special honest-verifier zero-knowledge proof:
  
   
\end{itemize}


In the Schnorr protocol, $g, h, c$ are group elements from underlying group, while 
$u, e, t$ are scalar values from underlying prime field. In practice, 
both the group elements and the fields elements are some large prime numbers,
albeit the operations differ. For most of the languages it does not matter, 
but also a potential source of bugs (cite thomas work here). However, 
we need to flesh down all the details while encoding it Coq. One possibility is 
to encode the Coq functions to work with concrete numbers but this leads to 
cumbersome proofs because of dealing with concrete numbers. In our formalisation, 
we decided to abstract the underlying group as an abstract type $G$, endowed with 
usual group operation, and the underlying field as an abstract type $F$, endowed with 
filed operation. Finally, we abstract these two types in an vector space. This 
makes our formalisation generic that can be instantiated with 
any kind of group and field as long as it follows the axioms of 
vector space. For example, in our formalisation we have developed 
efficient algorithm for Schnorr group but our formalisation can 
later be also instantiated with elliptic curve group. However, 
one of the major benefit of this abstraction is easiness of proofs 
which can be easily automated. Therefore, we model the Schnorr 
protoco, the simulator, and the verification equation in Coq as follows: 
 
\begin{lstlisting}[frame=single, language=Coq, caption={Schnorr protocol},
  label={ind_nat},captionpos=t, basicstyle=\ttfamily\footnotesize,
  abovecaptionskip=-\medskipamount]
(*Real transcript (involves secret x)*)
Definition schnorr_protocol (x : F) (g : G) 
 (u c : F) : sigma_proto :=  
 ([g^u]; [c]; [u + c * x]).

(*Fake transcript (without the witness x)*)
Definition schnorr_simulator (g h : G) 
 (u c : F) : sigma_proto := 
 ([gop (g^u) (h^(opp c))]; [c]; [u]).

(*This function checks if a transcript (a; c; r) 
is accepting or not. It checks if g^r = a * h^c*)
Definition accepting_conversation (g h : G) 
 (v : sigma_proto) : bool :=
 match v with
 | (a; c; r) =>  
    match Gdec (g^r) (gop a (h^c)) with 
    | left _ => true
    | right _ => false 
    end
 end.
\end{lstlisting}
  
\noindent
 where $F$ is the underlying field, $G$ is the underlying group,
 $+ : F \rightarrow F \rightarrow F$ is field addition,
 $* : F \rightarrow F \rightarrow F$ is field multiplication, and
 $\mbox{\textasciicircum}: G \rightarrow F \rightarrow G$ scalar multiplication of vector space.  
 Recall that a vector space consists of a set of 
 vectors, denoted by \(V\), a field \(F\) (elements of F are called scalars), and 
 two operations: vector addition and scalar multiplication.
\begin{itemize}
    \item \textit{Vector addition}: for any vectors \(\mathbf{v}, \mathbf{w} \in V\), their sum, denoted by \(\mathbf{v} + \mathbf{w}\), is also in \(V\).
    \item \textit{Scalar multiplication}: for any vector \(\mathbf{v} \in V\) and any scalar \(c \in F\), their product, denoted by \(c\mathbf{v}\), is also in \(V\).
\end{itemize}

These operations must satisfy the following properties for all vectors \(\mathbf{u}, \mathbf{v}, \mathbf{w} \in V\) and all scalars \(c, d \in F\):
(i) \textbf{closure under addition:} \(\mathbf{u} + \mathbf{v} \in V\), (ii) \textbf{commutativity of addition:} \(\mathbf{u} + \mathbf{v} = \mathbf{v} + \mathbf{u}\), 
(iii)  \textbf{associativity of addition:} \((\mathbf{u} + \mathbf{v}) + \mathbf{w} = \mathbf{u} + (\mathbf{v} + \mathbf{w})\), 
(iv) \textbf{existence of zero vector:} there exists a vector \(\mathbf{0} \in V\) such that \(\mathbf{v} + \mathbf{0} = \mathbf{v}\) for all \(\mathbf{v} \in V\), 
(v) \textbf{existence of additive inverse:} for each vector \(\mathbf{v} \in V\), there exists a vector \(-\mathbf{v} \in V\) such that \(\mathbf{v} + (-\mathbf{v}) = \mathbf{0}\),
(vi) \textbf{closure under scalar multiplication:} \(c\mathbf{v} \in V\), 
(vii) \textbf{cistributive properties:} \(c(\mathbf{u} + \mathbf{v}) = c\mathbf{u} + c\mathbf{v}\) and \((c + d)\mathbf{v} = c\mathbf{v} + d\mathbf{v}\), 
and (viii) \textbf{compatibility with field multiplication:} \(c(d\mathbf{v}) = (cd)\mathbf{v}\) and \(1\mathbf{v} = \mathbf{v}\), where \(1\) denotes the multiplicative identity in \(F\).
In our setting we instantiate the set of vectors with $G$ and field with $F$. 
Moreover, our notation for scalar multiplication is $\mbox{\textasciicircum}$ because it represents, 
when instantiated concretely, exponentiation function but it is purely for notational convenience. 


We prove the completeness and special soundness property of the Schnorr protocol, 
as shown in Lisitng \cite{comp_sound}. We however cannot prove the special honest-verifier 
zero-knowledge property yet because it requires reasoning about probability that 
we discuss in the next section. 
  
\begin{lstlisting}[frame=single, language=Coq, caption={Completeness and Soundness},
  label={comp_sound},captionpos=t, basicstyle=\ttfamily\footnotesize,
  abovecaptionskip=-\medskipamount]
Lemma schnorr_completeness : 
forall (r c : F) (a : t G 1) (c r : t F 1),
(a; c; r) = (schnorr_protocol x g r c) ->
accepting_conversation g h (a; c; r) = true.
Proof. (* proof terms omitted *) Qed.
  
Lemma simulator_completeness : 
forall (r c : F) (a : t G 1) (c r : t F 1),
(a; c; r) = (schnorr_simulator g h r c) ->
accepting_conversation g h (a; c; r) = true.
Proof using -(x R). (* terms omitted *) Qed. 
  
Lemma special_soundness: 
forall (a : G) (ca ra cb rb : F), ca <> cb ->
accepting_conversation g h ([a]; [ca]; [ra]) ->  
accepting_conversation g h ([a]; [cb]; [rb]) ->
exists y : F, g^y = h /\ y = ((ra - rb) * inv (ca - cb)).
Proof using -(x R). (* proof terms omitted *) Qed.
  
\end{lstlisting}
 





  
  \subsection{Uniform Distribution}
  To reason about special honest-verifier zero-knowledge proof 
  intuitively, we need a model of uniform distribution. 
  we encode distribution a list of tuples where the 
  second element of tuple basically is probability of first element 
  in the tuple. Moreover, we define equality on distribution by 
  stating that two distributions are equal if they are permutation 
  of each other. Finally, we define a function , $uniform\_with\_replacement$, 
  to generate uniform distributions. 

\begin{lstlisting}[frame=single, language=Coq, caption={Definition of Natural Number},
    label={ind_nat},captionpos=t, basicstyle=\ttfamily\footnotesize,
    abovecaptionskip=-\medskipamount]
    
(* Probability Distribution on a type A *)
Definition dist (A : Type) : Type := list (A * prob).
  
(* Uniform distribution u*)
Definition uniform_with_replacement {A : Type} : 
  forall (l : list A), l <> [] -> dist A.
Proof.
  intros ? H.
  remember (Pos.of_nat (List.length l)) as len.
  exact (List.map 
    (fun x => (x, mk_prob 1 len)) l).
Defined.
\end{lstlisting}

We prove that the dist is a monad (\textbf{Cite some work}) by 
giving it a suitable definitions of ret and bind. Making 
it an instance of monad makes our life easier because 
we can compose a distribution $d$ $n$ times to 
returns a distribution on a vector of $n$ elements. 


    
\begin{lstlisting}[frame=single, language=Coq, caption={Definition of Natural Number},
  label={ind_nat},captionpos=t, basicstyle=\ttfamily\footnotesize,
  abovecaptionskip=-\medskipamount]
(* Probability Monad *)
Definition Ret {A : Type} (x : A) : 
  dist A := [(x, one)].

Fixpoint Bind {A B : Type} (xs : dist A)  
  (f : A -> dist B) : dist B := 
  match xs with 
  | [] => [] 
  | (ax, px) :: tx => 
    List.append (List.map (fun '(ut, pt) => 
    (ut, mul_prob px pt)) (f ax)) (Bind tx f)
  end.


\end{lstlisting}

  
Now we have all the ingredients to prove the zero-knowledge 
proof of the Schnorr protocol. We define the 
Schnorr distribution $schnorr\_distribution$
that involves the secret $x$ and 
the simulator distribution $simulator\_distribution$
that does not involve the secret $x$. 
In the Schnorr distibution we draw 
a random field element $u$ from a uniform 
distribution $uniform\_with\_replacement \text{ }lf \text{ } Hlfn$
and use this $u$ to construct a distribution; 
similarly in the simulator distribution 
we draw a random field element $u$ from 
$uniform\_with\_replacement \text{ }lf \text{ } Hlfn$
and use it construct a distribution. Using these 
two definitions, we prove that these two 
distributions are identical 
$special\_honest\_verifier\_zkp$. However, 
contrary to informal reasoning, these two 
distributions are not syntactically equal but 
semantically equal. For both distributions, 
the first component is a transcript $(a, c, r)$ and 
the second component is a rational number that represents 
its probability. The triples in both distrubtions 
are an accepting transcript (semantic) but they 
are not identical and differ syntactically; 
therefore we first apply the 
$accepting\_conversation$ to the first pair of 
both distributions which turn them into 
a boolean value (true). After this  
application both distributions are identical 
that we prove. 




\begin{lstlisting}[frame=single, language=Coq, caption={Definition of Natural Number},
  label={ind_nat},captionpos=t, basicstyle=\ttfamily\footnotesize,
  abovecaptionskip=-\medskipamount]
(* Distribution that involves the secret x *)
Definition schnorr_distribution  (lf : list F) 
  (Hlfn : lf <> List.nil) (x : F) (g : G) (c : F) : 
  dist sigma_proto :=
  (* draw u from a random distribution *)
  u <- (uniform_with_replacement lf Hlfn) ;;
  Ret (schnorr_protocol x g u c).

  
(* without secret x *)
Definition simulator_distribution (lf : list F) 
  (Hlfn : lf <> List.nil) (g h : G) (c : F) : 
  dist sigma_proto :=
  (* draw u from a random distribution *)
  u <- (uniform_with_replacement lf Hlfn) ;;
  Ret (schnorr_simulator g h u c).
  
Lemma special_honest_verifier_zkp : 
  forall (lf : list F) (Hlfn : lf <> List.nil) (c : F), 
  List.map (fun '(a, p) => 
    (accepting_conversation g h a, p))
    (@schnorr_distribution lf Hlfn x g c) = 
  List.map (fun '(a, p) => 
    (accepting_conversation g h a, p))
    (@simulator_distribution lf Hlfn g h c).
Proof. (* proof terms omitted *) Qed. 
  \end{lstlisting}


We shown in the function $repeat\_dist\_ntimes\_vector$.
  The reader can see from the proof 
  $uniform\_probability\_multidraw\_prob$
  that if a distribution $lf$ is repeated 
  $n$ times then the probability of this distribution 
  is $1/|lf|^n$. We use $repeat\_dist\_ntimes\_vector$ 
  when we combine multiple sigma protocols and 
  want to to prove zero-knowledge property. For example, 
  in Parallel composition when we combine $n$ sigma protocol 
  we need to need to draw a vector $n$ random numbers to 
  prove the zero-knowledge property. 
  
  \begin{lstlisting}[frame=single, language=Coq, caption={Definition of Natural Number},
    label={ind_nat},captionpos=t, basicstyle=\ttfamily\footnotesize,
    abovecaptionskip=-\medskipamount]
Fixpoint repeat_dist_ntimes_vector {A : Type} 
(d : dist A) (n : nat) : dist (Vector.t A n) := 
match n with 
| 0 => Ret (@Vector.nil A)
| S n' => 
  Bind d (fun u => 
    Bind (repeat_dist_ntimes_vector d n')
    (fun v => Ret (Vector.cons _ u _ v)))
end.

Lemma uniform_probability_multidraw_prob 
{A : Type} : forall n (lf : dist A) 
(a : Vector.t A n) b (Hlf : lf <> []), 
In (a, b) (repeat_dist_ntimes_vector 
  (uniform_with_replacement lf Hlf) n) ->
b = mk_prob 1 (Pos.of_nat 
(Nat.pow (List.length lf) n)).


Definition parallel_schnorr_distribution  
  {n : nat} (lf : list F) (Hlfn : lf <> List.nil) 
  (x : F) (g : G) (cs : Vector.t F n) : 
  dist (@sigma_proto n n n) :=
  (* draw n random elements *)
  us <- repeat_dist_ntimes_vector 
    (uniform_with_replacement lf Hlfn) n ;;
  Ret (construct_parallel_schnorr x g us cs).
\end{lstlisting}


\subsection{Efficient Modular Arithmetic}
 As we stated that our formalisation is  
 abstract and can be instantiated with 
 a suitable group and field. In order 
 to run our code, we have developed 
 a formally verified Schnorr group (\textbf{cite here}). 
 \begin{lstlisting}[frame=single, language=Coq, caption={Definition of Natural Number},
  label={ind_nat},captionpos=t, basicstyle=\ttfamily\footnotesize,
  abovecaptionskip=-\medskipamount]
Section SchnorrGroup. 
  Context 
    {k p q : Z}
    {Hk : p = k * q + 1}
    {Hp : prime p}
    {Hq : prime q}.

  Record Schnorr_group := 
    mk_schnorr 
    {v : Z; Ha : 0 < v < p; 
    Hb : (v ^ q mod p = 1)}.

  (* Neutral Element *)
  Definition one : Schnorr_group.
    refine 
      (mk_schnorr 1 one_mod_p 
      one_pow_mod_q).
  Defined. 

  Definition mul_schnorr_group 
      (u v : Schnorr_group) : Schnorr_group.
  refine(
    match u, v with 
    | mk_schnorr au Hua Hub, 
      mk_schnorr av Hva Hvb => 
      mk_schnorr (Z.modulo (au * av) p) 
      (@multiplication_bound p Hp au 
      av Hua Hva)  _
    end).
  Defined. 

  (* u ^ (p - 2) is inverse of u *)
  Definition inv_schnorr_group 
  (u : Schnorr_group) : Schnorr_group.
  refine(
    match u with 
    | mk_schnorr au Hu Hv => mk_schnorr
        (Z.of_N (Npow_mod (Z.to_N au) 
        (Z.to_N (p - 2)) (Z.to_N p)))
        (@inv_schnorr_group_first au Hu)
        (inv_schnorr_group_second au Hu Hv)
    end).
  Defined.


  (* Schnorr is a commutative Group *)
  Global Instance schnorr_comm : 
    @commutative_group 
    Schnorr_group (@eq Schnorr_group) 
    mul_schnorr_group one inv_schnorr_group.
  Proof. ... Qed. 
  



\end{lstlisting}

Similarly, we have encoded a prime field. 

\begin{lstlisting}[frame=single, language=Coq, caption={Definition of Natural Number},
  label={ind_nat},captionpos=t, basicstyle=\ttfamily\footnotesize,
  abovecaptionskip=-\medskipamount]

(* Prime Field *)
Section ZpField.

  Context 
    {p : Z}
    {Hp : prime p}.

    
  Record Zp := 
    mk_zp {v : Z; Hv : Z.modulo v p = v}.


  Definition zp_inv (x : Zp) : Zp.
    refine (match x with
      | mk_zp ax Hu => mk_zp 
        (Z.modulo 
          (Z.of_N (Npow_mod (Z.to_N ax) 
          (Z.to_N (p - 2)) (Z.to_N p)))
          p) _ 
    end).
    rewrite Zmod_mod.
    exact eq_refl.
  Defined.


  Definition zp_div (x y : Zp) : Zp :=
    zp_mul x (zp_inv y).

  
\end{lstlisting}

Finally, we prove that they form a vector space. 
We have encoded the scalar mulitplication of 
vector space as a pow function that takes an element from 
a Schnorr group and an element from 
a given field and returns an element in the 
Schnorr group.  The reader can see that our encoding eliminates all 
possibilities of mixing group and field, both represented 
as an integer modulo some large 
prime \cite{10.1007/978-3-662-63958-0_24}.

\begin{lstlisting}[frame=single, language=Coq, caption={Definition of Natural Number},
  label={ind_nat},captionpos=t, basicstyle=\ttfamily\footnotesize,
  abovecaptionskip=-\medskipamount]

  Definition pow (g : @Schnorr.Schnorr_group p q) 
  (y : @Zpfield.Zp q) : @Schnorr.Schnorr_group p q.
  refine 
    match g, y with 
    | mk_schnorr gt Hgta Hgtb, Zpfield.mk_zp yt Hyt => 
      mk_schnorr  
      (Z.of_N (Npow_mod (Z.to_N gt) (Z.to_N yt) (Z.to_N p))) 
      (pow_subproof_first gt yt Hgta Hyt)
      (pow_subproof_second _ _  Hyt Hgta Hgtb)
    end.
  Defined.

  Global Instance pow_vspace : 
  @vector_space 
    (* Field *)
    (@Zpfield.Zp q) (@eq (@Zpfield.Zp q))
    (@Zpfield.zero q Hq) (@Zpfield.one q Hq)
    (@Zpfield.zp_add q) (@Zpfield.zp_mul q)
    (@Zpfield.zp_sub q) (@Zpfield.zp_div q)
    (@Zpfield.zp_opp q Hq) (@Zpfield.zp_inv q)
    (* Vector *)
    (Schnorr_group p q) (@eq (Schnorr_group p q))
    (@one p q Hp Hq) 
    (@inv_schnorr_group k p q Hk Hp Hq)
    (@Schnorr.mul_schnorr_group p q Hp Hq)
    pow.
  
\end{lstlisting}
  
  
 
\subsection{Fiat-Shamir Transform}
 We have formalised the interactive version of sigma protocol. However,
 interaction is not convenient and therefore
 we use Fiat-Shamir transform to make it non-interactive. We use SHA256 
 to turn the interaction to non-interaction but in order to 
 make it a self-contained library and 
 avoid relying on any external library at the front-end (WebAssembly)
 we have encoded the SHA256 in the Coq theorem prover, with usual correctness 
 properties. 


\section{Web Assembly and Rust from the Coq Formalisation (MetaCoq)}
  Bas Spitter


\section{Case Studies/Experiment}
  We use our formalisation to model the Cryptographic protocols implemented in 
  Helios voting systems. Compare it with state-of-the-art 
  crypto library. 


\section{Related Work, Future Work, and Limitations}
  There are three work. Giles Barthe does not extract to executable code, 
  CryptoHol uses law of excluded middle, and thomas haines work is more about 
  verifying a transcript rather than constructing it. Moreover, 
  it does not reason about probabilities in intuitive way. 

\textbf{find the shortcomings of these works}
Given the importance of sigma protocols in privacy-preserving voting systems,
it has been formalised before  \cite{5552642,butler2019formalisation,10.1145/3319535.3354247}. 
\cite{5552642,butler2019formalisation} are mainly focused on establishing the 
pen-and-paper proofs of sigma protocol into theorem provers and not extracting an executable code.
On the other hand, \cite{10.1145/3319535.3354247} extract an OCaml code from the Coq 
formalisation but it is mostly geared towards verifying an Helios election transcript, 
rather than constructing the primitives to conduct an election. Moreover, 
it does not reason about probabilities in an intuitive way.


  In this paper, we present a certified implementation 
  that can be readily used by voting community and 
  we demonstrated the usefulness by encoding Helios, 
  Belenois, and SwissPost using our primitives. 
  Moreover, our formalisation extracts to WebAssembly and 
  Rust without duplicate efforts. 


% references section

% can use a bibliography generated by BibTeX as a .bbl file
% BibTeX documentation can be easily obtained at:
% http://mirror.ctan.org/biblio/bibtex/contrib/doc/
% The IEEEtran BibTeX style support page is at:
% http://www.michaelshell.org/tex/ieeetran/bibtex/
\bibliographystyle{IEEEtran}
% argument is your BibTeX string definitions and bibliography database(s)
\bibliography{IEEEabrv,reference}




% that's all folks
\end{document}


