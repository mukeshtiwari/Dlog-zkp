\documentclass[conference,compsoc]{IEEEtran}
% Some/most Computer Society conferences require the compsoc mode option,
% but others may want the standard conference format.
%
% If IEEEtran.cls has not been installed into the LaTeX system files,
% manually specify the path to it like:
% \documentclass[conference,compsoc]{../sty/IEEEtran}





% Some very useful LaTeX packages include:
% (uncomment the ones you want to load)


\ifCLASSOPTIONcompsoc
  % IEEE Computer Society needs nocompress option
  % requires cite.sty v4.0 or later (November 2003)
  \usepackage[nocompress]{cite}
\else
  % normal IEEE
  \usepackage{cite}
\fi


\usepackage{listings}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{url}
\usepackage{lstcoq}
\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}
\begin{document}
\title{Hope}

\author{Anonymous}

% make the title area
\maketitle

% As a general rule, do not put math, special symbols or citations
% in the abstract
\begin{abstract}
  Despite the recent growth of zero-knowledge succinct argument 
  of knowledge (ZkSNARK) in cryptocurrencies, 
  sigma protocol remains a popular choice in electronic voting to maintain privacy 
  and verifiability of elections and still used in prominent e-voting systems such as 
  Helios, Belenois, SwissPost, etc. However, 
  the existing implementations of sigma protocol have two 
  shortcomings: (i) the same code is written twice, once for the front-end (JavaScript)
  and once for the back-end (Python/OCaml/Java), which is time-consuming but more importantly error-prone, 
  and (ii) none of these implementations offer any security guarantees. 
  
  In this paper, we present a certified implementation of sigma protocol in the Coq proof assistant and
  prove our implementation is (special) sound, complete, and 
  (honest verifier) zero-knowledge. Moreover, 
  we compile our Coq formalisation to WebAssembly and Rust; 
  thereby solve the problem of writing the same code twice. 
  We demonstrate the applicability of our
  formalisation by encoding the sigma protcol implemented in 
  Helios, Belenois, and SwissPost voting systems. 
  Our long terms goal is to provide a verified cryptographic library that can be 
  readily used in privacy-preserving voting systems.
\end{abstract}

% no keywords




% For peer review papers, you can put extra information on the cover
% page as needed:
% \ifCLASSOPTIONpeerreview
% \begin{center} \bfseries EDICS Category: 3-BBND \end{center}
% \fi
%
% For peerreview papers, this IEEEtran command inserts a page break and
% creates the second title. It will be ignored for other modes.
\IEEEpeerreviewmaketitle



\iffalse
\section{How to pitch this paper and What is the unique selling point of our work?}
Our Coq formalisation can be used at front-end (WebAssembly code) and 
back-end (Rust). Contrary to the existing work, our formalisation
does not write the same code twice. But sigma protocol is arcane and has 
been formalised couple of times before so why another formalisation?
None of the formalisation has been able to extract the code to executable code 
and one that was able to do so did not reason about probabilities in an intuitive way.
Moreover, that work was just geared towards verifying a transcript rather than
constructing it. Also, recently ZKP community started a movement to 
formalise the sigma protocols. We also demonstrates the 
applicability of our formalisation by encoding Helios cryptographic protocols
in our formalisation. 



\textbf{We need to explain why formal verification is important in the context of voting systems.}

\begin{itemize}
  \item Explain zero-knowledge proofs (completeness, soundness, zero-knowledge)
  \item Explain sigma protocols (completeness, special-soundness, honest-verifier zero-knowledg) 
  and mention about the Schnorr protocol
  \item Our contribution
  \item Explain the Schnorr protocol
  \item Explain Parallel, And, Eq, Or, and NEQ relations (also explain that 
  most of the formalisation has worked on And and Or relations)
\end{itemize}

\fi




\section{Introduction}
Electronic voting offers convenience and efficiency in electoral processes, potentially improving 
accessibility for disabled voters, increasing participation among overseas voters, and lowering 
the costs associated with conducting elections. Moreover,
they can streamline the voting process, reduce administrative burdens, and enable 
faster tallying of results. However, the transition to electronic voting also brings significant 
challenges, particularly in ensuring the privacy and verifiability of the voting process. Therefore, 
privacy and verifiability are two crucial elements that a voting system must ensure to adhere with 
the principles of a free-and-fair election. In a paper-ballot election, privacy is maintained by 
ensuring that no identifying information is present on a ballot that links it to a particular voter, 
and verifiability is achieved through scrutineers closely observing various electoral processes, 
including the counting of ballots. In order to have a similar effect in electronic voting, encryption 
is employed to safeguard the privacy of voter choices, while publicly verifiable evidence 
(such as zero-knowledge proofs) allows voters and independent observers to verify the integrity of 
the voting process. However, no matter how advanced the cryptographic techniques, they are useless 
if their software implementation contains bugs.
In fact, due to a major cryptographic flaw that
could let someone change votes cast using Switzerland's online 
voting software without being detected  \cite{9152765}, the Swiss Federal Chancellery suspended electronic voting in 
2019. It only resumed in 2023 after getting feedbacks from academic 
community \cite{swiss_evoting_chronik} about various component used in 
the electronic voting software. However, it is not an isolated  
instance where bugs have been found in a voting software, e.g., 
Voatz \cite{255334} (used in West Virginia, USA election),
Democracy Live Online Voting System \cite{263858} 
(used in Delaware, West Virginia, and New Jersey, USA election), 
Moscow Internet Voting System \cite{10.1007/978-3-030-51280-4_3}
(used in Russia election), and iVote System \cite{10.1007/978-3-319-22270-7_3, 10.1145/3014812.3014837} 
(used in New South Wales, Australia election), etc. 
These unfortunate situations can largely be attributed to two factors: 
(i) closed source code (proprietary artifacts) because most of these bugs were 
discovered by researchers who inspected the code after they were made public, and 
(ii) software testing which is inadequate to rule out all the bugs 
from a software. Therefore, to avoid the situations like this, 
an electronic voting system must adhere to \textit{software independence}\cite{rivest2008notion}:
\begin{quote}
  A voting system is software-independent if an
  (undetected) change or error in its software cannot
  cause an undetectable change or error in an
  election outcome. 
\end{quote}
\noindent
Therefore, many electronic voting systems follow the principals 
of \textit{end-to-end verifiability}. End-to-end verifiability is 
defined as: 
\begin{itemize}
  \item Cast-as-intended: voters get proof that the electronic ballot accurately reflects their choices.
  \item Collected-as-cast: the election authority provides proof that the electronic ballots are received without tampering.
  \item Counted-as-collected: the election authority provides proof that the results are based on correctly counting all received ballots.
\end{itemize} 


\noindent 
Finally, voters or scrutineers inspect these proofs and accept or reject the election results based on 
the verification of these proofs. In practice, this means that during the execution of an election, 
electronic voting software generates data, and voters and scrutineers verify the conformity of 
this data using independently written computer programs. The rationale is that if there is 
any discrepancy in the electronic voting system, at least one scrutineer or voter would detect it.
It is important to note that end-to-end verifiability is a valuable feature because it 
allows for the verification of the election results by checking the proofs of correctness 
only after the election has concluded. This ensures that the election process was conducted 
properly and that the results are accurate, but it is applied after the voting has taken place.
The question arises: can we use it before an election?
The answer is yes; we use a formal language to express end-to-end verifiability, or parts of 
it and develop various components of electronic voting 
software in this formal language. This process is called as formal verification and it ensures 
that the software always produces valid proofs, 
which are consistently accepted by voters and scrutineers. In other words, formal verification
can be employed to develop reliable electronic voting software.
In fact, formal verification has emerged as a promising solution 
to eliminate potential bugs from software, and in recent years it has been increasingly 
adopted in real-world software applications \cite{10.1145/1111037.1111042}, 
including cryptography \cite{8835346,10.1145/3133956.3134043,190894,10.1145/2701415,
10.1145/2660267.2660370,10.1145/3319535.3363211}.

In this paper, we present a certified implementation of the Sigma protocol --an efficient 
type of zero-knowledge proof-- and its Parallel, And, Eq, Or, and Neq compositions in 
the formal language of Coq proof assistant. Given that the formal language of Coq 
is constructive, we get an implementation that can be executed on a computer. 

We have formalised and analysed the interactive version of 
the Sigma protocol, but in practice it is not convenient due to the required interaction. 
Therefore, all Sigma protocol implementations use the Fiat-Shamir 
transformation \cite{10.5555/36664.36676} to make them non-interactive. This involves 
using a hash function to replace the randomness of the public-coin verifier, though 
some care is required \cite{10.1007/978-3-642-34961-4_38}.
To make our formalisation self-contained and independent of external libraries, we have 
encoded SHA-256 in Coq and proven its usual correctness properties. Additionally, we 
have implemented efficient prime field arithmetic procedures and the Schnorr group to 
ensure our library is concrete and executable. Finally, we extract WebAssembly and 
Rust code from our certified implementation, one of the novelties of our 
formalisation.


There are numerous implementations of sigma protocol in various languages, 
e.g., Helios is written in Python, Belenois is written in OCaml, and SwissPost is written in Java.
However, there are two main issues with these implementations: 
(i) the same code is written twice 
once for the front-end (JavaScript, TypeScript) and once for the back-end (Python, OCaml, or Java) and 
(ii) none of these implementations offer any formal guarantees about the correctness of the code.
Therefore, we use our formalisation to model the sigma protocol implemented in Helios, 
Belenois, and SwissPost voting systems to demonstrate the usablity of 
our library. Unlike Helios and SwissPost,
we write one implementation and extract WebAssembly (front-end) and Rust (back-end). 
Belenois is slightly different in this respect and uses Js\_of\_ocaml 
to compile the OCaml code into JavaScript so it has only one 
implementation written in OCaml; nonetheless it is not verified 
and offers no formal guarantees. To the best of our knowledge, 
this is the firstformal verification of sigma protocol that can be used at 
the front-end (WebAssembly code) and back-end (Rust code). 

\subsection{Outline}


\section{Sigma Protocol}
Despite the recent growth and popularity of zero-knowledge succinct 
argument of knowledge (ZKSNARK), sigma protocol remains a
leading cryptographic proof system in privacy-preserving voting systems. 
Sigma protocol is used in Helios --a widely popular voting system-- \cite{adida2008helios}, 
Belenois --used in French elections for overseas 
voters\footnote{VVFE, used in French elections, is a derivative of (part of) Belenios and 
inherited all the zero-knowledge proofs from Belenois.}-- \cite{cortier2023french}, and 
SwissPost --used in Swiss elections for overseas voters-- voting 
systems \cite{10.1007/978-3-031-15911-4_4} (\textbf{Look for more examples}). 
Moreover, recently zero-knowledge proof community started a movement to standardise
the sigma protocol \cite{ZKProof}.
One of the main reasons for its popularity in privacy-preserving voting systems is its
well-understood security.  Other application of sigma protocol 
include identification schemes, (cite more work). 

%\textbf{Introduce here that sigma protocol is efficient and simple and all other details about sigma protocol.} 
Zero-knowledge proofs were first studied by Goldwasser, Micali, and Rackoff \cite{10.1145/22145.22178} and 
are possible for all problems in $NP$ \cite{10.1145/116825.116852}. Recall that $NP$ is the class of 
problems that have efficient verifiers; that is, for a given problem in the $NP$ class, there is 
a polynomial-time algorithm that can verify whether a given solution, or witness, to the problem is correct or not.
More formally, for a given $NP$-relation $R$ and a statement $x$, zero-knowledge proof allows a prover 
$P$ to convince a verifier $V$ that they posses a witness $w$ --polynomial in length of $x$-- such 
that ($x$, $w$) $\in$ $R$. To accomplish this, $P$ and $V$ engage in a 
interactive protocol and  at the end of the protocol $V$ either accepts or rejects the proofs.
\textit{Sigma protocol}, \textbf{shown in the figure }, is an efficient three move zero-knowledge proof where the 
verifier is assumed to be honest and characterised by completeness, (special) soundness, and 
(special honest-verifier) zero-knowledge. More formally: 
\begin{itemize}
  \item \textbf{Completeness:}
  when $P$ and $V$ follow the protocol, $V$ always accepts. 
  In other words, if $P$ knows $w$ for $x$ such that ($x$, $w$) $\in$ $R$,  
  then $P$ can successfully construct a proof $(a, c, r)$ that always passes the verification equation, 
  i.e., $V$ accepts. 

\item \textbf{Special soundness:}
there exists a polynomial-time extractor $E$ which given 
two accepting transcripts $(a, c, r)$ and $(a, c', r')$ for $x$, 
it can extract a witness $w$ such that $(x, w) \in R$. In other words, 
if $P$ does not know $w$ for $x$ then it cannot construct a proof 
(a; c; r) that will passes the verification check. 
\item \textbf{Special honest-verifier zero-knowledge proof:}
There exists a polynomial-time simulator $S$ that, for any 
$v \in L_R$ where $L_R = \{x  \mid (x, w) \in R\}$,
generates an accepting transcript $(a, c, r)$ 
without using the witness $w$. 
This transcript is indistinguishable from one produced by an 
honest conversation between $P$ and $V$ using $w$, 
satisfying $(v,w) \in R$.

\end{itemize}

\textbf{Draw a picture here of sigma protocol}







Sigma protocol was first defined by Ronald Cramer \cite{cramer1996modular} 
and the first efficient sigma protocol was introduced by Schnorr in \cite{schnorr1991efficient}. 
Eventhough there exists many sigma protocols, the Schnorr protocol is used extensively in privacy-preserving voting systems, e.g, Helios, Belenois, SwissPost, etc. Therefore, 
our formalisation is geared towards the Schnorr protocol. 
Moreover, we also formalise the composition of (i) $n$ \textit{Parallel} Schnorr, 
(i) $n$ \textit{And} Schnorr, (iii) $n$ \textit{Or} Schnorr, and (iv) $n$ \textit{Eq} Schnorr protocol. 
Ideally, given the abstraction of our formlisation (\textit{vector space}), we could have 
abstracted the sigma protocol and their composition in a generic way \cite{10.1007/978-3-642-02384-2_17},
but we decided to focus on the Schnorr protocol and its composition to ensure familiar APIs 
for e-voting in WebAssembly and Rust. We also formalise Okamoto protocol as a subprotocol 
for Neq composition (\textbf{Berry: does it sound okay?}). However, we have not seen 
much use of Neq in the privacy-preserving voting systems, at least in the existing voting systems. 






\section{Coq formalisation}

  We briefly explain the Schnorr protocol, which is very similar to figure \textbf{refer here to sigma protocol picture}.
  Given some public input $(G, g, q, h)$ where $G$
  is a cyclic group of prime order $q$, $g$ and $h$ are two 
  generators of the group $G$, the prover claims that they know a
  witness $w$ for the statement $h = g^w$; the existence of such
  a $w$ is immediate because $g$ generates the group. However,
  does the prover know the witness $w$? In order to convince the
  verifier, the prover and the verifier do the following:
  \begin{itemize}
    \item the prover picks a random number $u$, computes $c = g^u$,
    and sends $c$ to the verifier.
    \item the verifier picks a random challenge $e$ and sends it to
    the prover
    \item the prover computes $t = u + e * w$ and sends $t$ to the
    verifier
  \end{itemize}

The verifier accepts if $g^t = c * h^e$, otherwise rejects. We can prove that 
this protocol has completeness, special soundness, and special honest-verifier 
zero-knowledge proof. 


\begin{itemize}
  \item completeness: when $P$ and $V$ both follows the protocol, $V$ accepts the proof, i.e., 
  the verification equation checks. We can see by algebraic simplification that is the case.
    \begin{align*}
      g^t = g^{u + e * w} = g^u * (g^w)^e = c * h^e
    \end{align*}
  \item special soundness: 

  \item special honest-verifier zero-knowledge proof:
   
\end{itemize}


In the Schnorr protocol, $g, h, c$ are group elements from underlying group, while 
$u, e, t$ are scalar values from underlying prime field. In practice, 
both the group elements and the fields elements are some large prime numbers,
albeit the operations differ. For most of the languages it does not matter, 
but also a potential source of bugs (cite thomas work here). However, 
we need to flesh down all the details while encoding it Coq. One possibility is 
to encode the Coq functions to work with concrete numbers but this leads to 
cumbersome proofs because of dealing with concrete numbers. In our formalisation, 
we decided to abstract the underlying group as an abstract type $G$, endowed with 
usual group operation, and the underlying field as an abstract type $F$, endowed with 
filed operation. Finally, we abstract these two types in an vector space. This 
makes our formalisation generic that can be instantiated with 
any kind of group and field as long as it follows the axioms of 
vector space. For example, in our formalisation we have developed 
efficient algorithm for Schnorr group but our formalisation can 
later be also instantiated with elliptic curve group. However, 
one of the major benefit of this abstraction is easiness of proofs 
which can be easily automated. Therefore, we model the Schnorr 
protoco, the simulator, and the verification equation in Coq as follows: 
 
\begin{lstlisting}[language=Coq]
(*Real transcript (involves secret x)*)
Definition schnorr_protocol (x : F) (g : G) (u c : F) : 
 sigma_proto :=  ([g^u]; [c]; [u + c * x]).

(*Fake transcript (without the witness x)*)
Definition schnorr_simulator (g h : G) (u c : F) :
  sigma_proto := ([gop (g^u) (h^(opp c))]; [c]; [u]).

(*This function checks if a transcript 
(a; c; r) is accepting or not. It checks
if g^r = a * h^c*)
Definition accepting_conversation 
  (g h : G) (v : sigma_proto) : bool :=
  match v with
  | (a; c; r) =>  
    match Gdec (g^r) (gop a (h^c)) with 
    | left _ => true
    | right _ => false 
    end
  end.
\end{lstlisting}
  
\noindent
 where $F$ is the underlying field, $G$ is the underlying group,
 $+ : F \rightarrow F \rightarrow F$ is field addition,
 $* : F \rightarrow F \rightarrow F$ is field multiplication, and
 $\mbox{\textasciicircum}: G \rightarrow F \rightarrow G$ scalar multiplication of vector space.  
 Recall that a vector space consists of a set of 
 vectors, denoted by \(V\), a field \(F\) (elements of F are called scalars), and 
 two operations: vector addition and scalar multiplication.
\begin{itemize}
    \item \textit{Vector addition}: for any vectors \(\mathbf{v}, \mathbf{w} \in V\), their sum, denoted by \(\mathbf{v} + \mathbf{w}\), is also in \(V\).
    \item \textit{Scalar multiplication}: for any vector \(\mathbf{v} \in V\) and any scalar \(c \in F\), their product, denoted by \(c\mathbf{v}\), is also in \(V\).
\end{itemize}

These operations must satisfy the following properties for all vectors \(\mathbf{u}, \mathbf{v}, \mathbf{w} \in V\) and all scalars \(c, d \in F\):
(i) \textbf{closure under addition:} \(\mathbf{u} + \mathbf{v} \in V\), (ii) \textbf{commutativity of addition:} \(\mathbf{u} + \mathbf{v} = \mathbf{v} + \mathbf{u}\), 
(iii)  \textbf{associativity of addition:} \((\mathbf{u} + \mathbf{v}) + \mathbf{w} = \mathbf{u} + (\mathbf{v} + \mathbf{w})\), 
(iv) \textbf{existence of zero vector:} there exists a vector \(\mathbf{0} \in V\) such that \(\mathbf{v} + \mathbf{0} = \mathbf{v}\) for all \(\mathbf{v} \in V\), 
(v) \textbf{existence of additive inverse:} for each vector \(\mathbf{v} \in V\), there exists a vector \(-\mathbf{v} \in V\) such that \(\mathbf{v} + (-\mathbf{v}) = \mathbf{0}\),
(vi) \textbf{closure under scalar multiplication:} \(c\mathbf{v} \in V\), 
(vii) \textbf{cistributive properties:} \(c(\mathbf{u} + \mathbf{v}) = c\mathbf{u} + c\mathbf{v}\) and \((c + d)\mathbf{v} = c\mathbf{v} + d\mathbf{v}\), 
and (viii) \textbf{compatibility with field multiplication:} \(c(d\mathbf{v}) = (cd)\mathbf{v}\) and \(1\mathbf{v} = \mathbf{v}\), where \(1\) denotes the multiplicative identity in \(F\).
In our setting we instantiate the set of vectors with $G$ and field with $F$. 
Moreover, our notation for scalar multiplication is $\mbox{\textasciicircum}$ because it represents, 
when instantiated concretely, exponentiation function but it is purely for notational convenience. 


We prove the completeness and special soundness property of the Schnorr protocol, 
as shown in the figure .... We however cannot prove the special honest-verifier 
zero-knowledge property yet because it requires reasoning about probability that 
we discuss in the next section. 
  
\begin{lstlisting}[language=Coq]
Lemma schnorr_completeness : 
forall (r c : F) (a : t G 1) (c r : t F 1),
(a; c; r) = (schnorr_protocol x g r c) ->
accepting_conversation g h (a; c; r) = true.
Proof. (* proof terms omitted *) Qed.
  
Lemma simulator_completeness : 
forall (r c : F) (a : t G 1) (c r : t F 1),
(a; c; r) = (schnorr_simulator g h r c) ->
accepting_conversation g h (a; c; r) = true.
Proof using -(x R). (* terms omitted *) Qed. 
  
Lemma special_soundness: 
forall (a : G) (ca ra cb rb : F), ca <> cb ->
accepting_conversation g h ([a]; [ca]; [ra]) = true ->  
accepting_conversation g h ([a]; [cb]; [rb]) = true ->
exists y : F, g^y = h /\ y = ((ra - rb) * inv (ca - cb)).
Proof using -(x R). (* proof terms omitted *) Qed.
  
\end{lstlisting}
 





  
  \subsection{Uniform Distribution}
  To reason about special honest-verifier zero-knowledge proof 
  intuitively, we need a model of uniform distribution. 
  we encode distribution a list of tuples where the 
  second element of tuple basically is probability of first element 
  in the tuple. Moreover, we define equality on distribution by 
  stating that two distributions are equal if they are permutation 
  of each other. Finally, we define a function , $uniform\_with\_replacement$, 
  to generate uniform distributions. 

  \begin{lstlisting}[language=Coq]
    
(* Probability Distribution on a type A *)
Definition dist (A : Type) : Type := list (A * prob).
  
(* Uniform distribution u*)
Definition uniform_with_replacement {A : Type} : 
  forall (l : list A), l <> [] -> dist A.
Proof.
  intros ? H.
  remember (Pos.of_nat (List.length l)) as len.
  exact (List.map 
    (fun x => (x, mk_prob 1 len)) l).
Defined.
\end{lstlisting}

We prove that the dist is a monad (\textbf{Cite some work}) by 
giving it a suitable definitions of ret and bind. Making 
it an instance of monad makes our life easier because 
we can compose a distribution $d$ $n$ times to 
returns a distribution on a vector of $n$ elements. 


    
\begin{lstlisting}[language=Coq]
(* Probability Monad *)
Definition Ret {A : Type} (x : A) : 
  dist A := [(x, one)].

Fixpoint Bind {A B : Type} (xs : dist A)  
  (f : A -> dist B) : dist B := 
  match xs with 
  | [] => [] 
  | (ax, px) :: tx => 
    List.append (List.map (fun '(ut, pt) => 
    (ut, mul_prob px pt)) (f ax)) (Bind tx f)
  end.


\end{lstlisting}

  
Now we have all the ingredients to prove the zero-knowledge 
proof of the Schnorr protocol. We define the 
Schnorr distribution $schnorr\_distribution$
that involves the secret $x$ and 
the simulator distribution $simulator\_distribution$
that does not involve the secret $x$. 
In the Schnorr distibution we draw 
a random field element $u$ from a uniform 
distribution $uniform\_with\_replacement \text{ }lf \text{ } Hlfn$
and use this $u$ to construct a distribution; 
similarly in the simulator distribution 
we draw a random field element $u$ from 
$uniform\_with\_replacement \text{ }lf \text{ } Hlfn$
and use it construct a distribution. Using these 
two definitions, we prove that these two 
distributions are identical 
$special\_honest\_verifier\_zkp$. However, 
contrary to informal reasoning, these two 
distributions are not syntactically equal but 
semantically equal. For both distributions, 
the first component is a transcript $(a, c, r)$ and 
the second component is a rational number that represents 
its probability. The triples in both distrubtions 
are an accepting transcript (semantic) but they 
are not identical and differ syntactically; 
therefore we first apply the 
$accepting\_conversation$ to the first pair of 
both distributions which turn them into 
a boolean value (true). After this  
application both distributions are identical 
that we prove. 




\begin{lstlisting}[language=Coq]
(* Distribution that involves the secret x *)
Definition schnorr_distribution  (lf : list F) 
  (Hlfn : lf <> List.nil) (x : F) (g : G) (c : F) : 
  dist sigma_proto :=
  (* draw u from a random distribution *)
  u <- (uniform_with_replacement lf Hlfn) ;;
  Ret (schnorr_protocol x g u c).

  
(* without secret x *)
Definition simulator_distribution (lf : list F) 
  (Hlfn : lf <> List.nil) (g h : G) (c : F) : 
  dist sigma_proto :=
  (* draw u from a random distribution *)
  u <- (uniform_with_replacement lf Hlfn) ;;
  Ret (schnorr_simulator g h u c).
  
Lemma special_honest_verifier_zkp : 
  forall (lf : list F) (Hlfn : lf <> List.nil) (c : F), 
  List.map (fun '(a, p) => 
    (accepting_conversation g h a, p))
    (@schnorr_distribution lf Hlfn x g c) = 
  List.map (fun '(a, p) => 
    (accepting_conversation g h a, p))
    (@simulator_distribution lf Hlfn g h c).
Proof. (* proof terms omitted *) Qed. 
  \end{lstlisting}


We shown in the function $repeat\_dist\_ntimes\_vector$.
  The reader can see from the proof 
  $uniform\_probability\_multidraw\_prob$
  that if a distribution $lf$ is repeated 
  $n$ times then the probability of this distribution 
  is $1/|lf|^n$. We use $repeat\_dist\_ntimes\_vector$ 
  when we combine multiple sigma protocols and 
  want to to prove zero-knowledge property. For example, 
  in Parallel composition when we combine $n$ sigma protocol 
  we need to need to draw a vector $n$ random numbers to 
  prove the zero-knowledge property. 
  
\begin{lstlisting}[language=Coq]
Fixpoint repeat_dist_ntimes_vector {A : Type} 
(d : dist A) (n : nat) : dist (Vector.t A n) := 
match n with 
| 0 => Ret (@Vector.nil A)
| S n' => 
  Bind d (fun u => 
    Bind (repeat_dist_ntimes_vector d n')
    (fun v => Ret (Vector.cons _ u _ v)))
end.

Lemma uniform_probability_multidraw_prob 
{A : Type} : forall n (lf : dist A) 
(a : Vector.t A n) b (Hlf : lf <> []), 
In (a, b) (repeat_dist_ntimes_vector 
  (uniform_with_replacement lf Hlf) n) ->
b = mk_prob 1 (Pos.of_nat 
(Nat.pow (List.length lf) n)).


Definition parallel_schnorr_distribution  
  {n : nat} (lf : list F) (Hlfn : lf <> List.nil) 
  (x : F) (g : G) (cs : Vector.t F n) : 
  dist (@sigma_proto n n n) :=
  (* draw n random elements *)
  us <- repeat_dist_ntimes_vector 
    (uniform_with_replacement lf Hlfn) n ;;
  Ret (construct_parallel_schnorr x g us cs).
\end{lstlisting}


\subsection{Efficient Modular Arithmetic}
 As we stated that our formalisation is  
 abstract and can be instantiated with 
 a suitable group and field. In order 
 to run our code, we have developed 
 a formally verified Schnorr group (\textbf{cite here}). 
\begin{lstlisting}[language=Coq]
Section SchnorrGroup. 
  Context 
    {k p q : Z}
    {Hk : p = k * q + 1}
    {Hp : prime p}
    {Hq : prime q}.

  Record Schnorr_group := 
    mk_schnorr 
    {v : Z; Ha : 0 < v < p; 
    Hb : (v ^ q mod p = 1)}.

  (* Neutral Element *)
  Definition one : Schnorr_group.
    refine 
      (mk_schnorr 1 one_mod_p 
      one_pow_mod_q).
  Defined. 

  Definition mul_schnorr_group 
      (u v : Schnorr_group) : Schnorr_group.
  refine(
    match u, v with 
    | mk_schnorr au Hua Hub, 
      mk_schnorr av Hva Hvb => 
      mk_schnorr (Z.modulo (au * av) p) 
      (@multiplication_bound p Hp au 
      av Hua Hva)  _
    end).
  Defined. 

  (* u ^ (p - 2) is inverse of u *)
  Definition inv_schnorr_group 
  (u : Schnorr_group) : Schnorr_group.
  refine(
    match u with 
    | mk_schnorr au Hu Hv => mk_schnorr
        (Z.of_N (Npow_mod (Z.to_N au) 
        (Z.to_N (p - 2)) (Z.to_N p)))
        (@inv_schnorr_group_first au Hu)
        (inv_schnorr_group_second au Hu Hv)
    end).
  Defined.


  (* Schnorr is a commutative Group *)
  Global Instance schnorr_comm : 
    @commutative_group 
    Schnorr_group (@eq Schnorr_group) 
    mul_schnorr_group one inv_schnorr_group.
  Proof. ... Qed. 
  



\end{lstlisting}

Similarly, we have encoded a prime field. 

\begin{lstlisting}[language=Coq]

(* Prime Field *)
Section ZpField.

  Context 
    {p : Z}
    {Hp : prime p}.

    
  Record Zp := 
    mk_zp {v : Z; Hv : Z.modulo v p = v}.


  Definition zp_inv (x : Zp) : Zp.
    refine (match x with
      | mk_zp ax Hu => mk_zp 
        (Z.modulo 
          (Z.of_N (Npow_mod (Z.to_N ax) 
          (Z.to_N (p - 2)) (Z.to_N p)))
          p) _ 
    end).
    rewrite Zmod_mod.
    exact eq_refl.
  Defined.


  Definition zp_div (x y : Zp) : Zp :=
    zp_mul x (zp_inv y).

  
\end{lstlisting}

Finally, we prove that they form a vector space. 
We have encoded the scalar mulitplication of 
vector space as a pow function that takes an element from 
a Schnorr group and an element from 
a given field and returns an element in the 
Schnorr group.  The reader can see that our encoding eliminates all 
possibilities of mixing group and field, both represented 
as an integer modulo some large 
prime \cite{10.1007/978-3-662-63958-0_24}.

\begin{lstlisting}[language=Coq]

  Definition pow (g : @Schnorr.Schnorr_group p q) 
  (y : @Zpfield.Zp q) : @Schnorr.Schnorr_group p q.
  refine 
    match g, y with 
    | mk_schnorr gt Hgta Hgtb, Zpfield.mk_zp yt Hyt => 
      mk_schnorr  
      (Z.of_N (Npow_mod (Z.to_N gt) (Z.to_N yt) (Z.to_N p))) 
      (pow_subproof_first gt yt Hgta Hyt)
      (pow_subproof_second _ _  Hyt Hgta Hgtb)
    end.
  Defined.

  Global Instance pow_vspace : 
  @vector_space 
    (* Field *)
    (@Zpfield.Zp q) (@eq (@Zpfield.Zp q))
    (@Zpfield.zero q Hq) (@Zpfield.one q Hq)
    (@Zpfield.zp_add q) (@Zpfield.zp_mul q)
    (@Zpfield.zp_sub q) (@Zpfield.zp_div q)
    (@Zpfield.zp_opp q Hq) (@Zpfield.zp_inv q)
    (* Vector *)
    (Schnorr_group p q) (@eq (Schnorr_group p q))
    (@one p q Hp Hq) 
    (@inv_schnorr_group k p q Hk Hp Hq)
    (@Schnorr.mul_schnorr_group p q Hp Hq)
    pow.
  
\end{lstlisting}
  
  
 



  \subsection{Fiat-Shamir Transform}
 We have formalised the interactive version of sigma protocol. However,
 interaction is not convenient and therefore
 we use Fiat-Shamir transform to make it non-interactive. We use SHA256 
 to turn the interaction to non-interaction but in order to 
 make it a self-contained library and 
 avoid relying on any external library at the front-end (WebAssembly)
 we have encoded the SHA256 in the Coq theorem prover, with usual correctness 
 properties. 


\section{MetaCoq}
  Bas Spitters 

\section{Web Assembly and Rust from the Coq Formalisation}
  Bas Spitter


\section{Case Studies/Experiment}
  We use our formalisation to model the Cryptographic protocols implemented in 
  Helios voting systems. Compare it with state-of-the-art 
  crypto library. 


\section{Related Work}
  There are three work. Giles Barthe does not extract to executable code, 
  CryptoHol uses law of excluded middle, and thomas haines work is more about 
  verifying a transcript rather than constructing it. Moreover, 
  it does not reason about probabilities in intuitive way. 

\textbf{find the shortcomings of these works}
Given the importance of sigma protocols in privacy-preserving voting systems,
it has been formalised before  \cite{5552642,butler2019formalisation,10.1145/3319535.3354247}. 
\cite{5552642,butler2019formalisation} are mainly focused on establishing the 
pen-and-paper proofs of sigma protocol into theorem provers and not extracting an executable code.
On the other hand, \cite{10.1145/3319535.3354247} extract an OCaml code from the Coq 
formalisation but it is mostly geared towards verifying an Helios election transcript, 
rather than constructing the primitives to conduct an election. Moreover, 
it does not reason about probabilities in an intuitive way.


\section{Conclusion, Future Work, and Limitations}
  In this paper, we present a certified implementation 
  that can be readily used by voting community and 
  we demonstrated the usefulness by encoding Helios, 
  Belenois, and SwissPost using our primitives. 
  Moreover, our formalisation extracts to WebAssembly and 
  Rust without duplicate efforts. 


% references section

% can use a bibliography generated by BibTeX as a .bbl file
% BibTeX documentation can be easily obtained at:
% http://mirror.ctan.org/biblio/bibtex/contrib/doc/
% The IEEEtran BibTeX style support page is at:
% http://www.michaelshell.org/tex/ieeetran/bibtex/
\bibliographystyle{IEEEtran}
% argument is your BibTeX string definitions and bibliography database(s)
\bibliography{IEEEabrv,reference}




% that's all folks
\end{document}


