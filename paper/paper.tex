%%
%% This is file `sample-sigplan.tex',
%% generated with the docstrip utility.
%%
%% The original source files were:
%%
%% samples.dtx  (with options: `all,proceedings,bibtex,sigplan')
%% 
%% IMPORTANT NOTICE:
%% 
%% For the copyright see the source file.
%% 
%% Any modified versions of this file must be renamed
%% with new filenames distinct from sample-sigplan.tex.
%% 
%% For distribution of the original source see the terms
%% for copying and modification in the file samples.dtx.
%% 
%% This generated file may be distributed as long as the
%% original source files, as listed above, are part of the
%% same distribution. (The sources need not necessarily be
%% in the same archive or directory.)
%%
%%
%% Commands for TeXCount
%TC:macro \cite [option:text,text]
%TC:macro \citep [option:text,text]
%TC:macro \citet [option:text,text]
%TC:envir table 0 1
%TC:envir table* 0 1
%TC:envir tabular [ignore] word
%TC:envir displaymath 0 word
%TC:envir math 0 word
%TC:envir comment 0 0
%%
%%
%% The first command in your LaTeX source must be the \documentclass
%% command.
%%
%% For submission and review of your manuscript please change the
%% command to \documentclass[manuscript, screen, review]{acmart}.
%%
%% When submitting camera ready or to TAPS, please change the command
%% to \documentclass[sigconf]{acmart} or whichever template is required
%% for your publication.
%%
%%
\documentclass[sigconf]{acmart}

%%
%% \BibTeX command to typeset BibTeX logo in the docs
\AtBeginDocument{%
  \providecommand\BibTeX{{%
    Bib\TeX}}}

%% Rights management information.  This information is sent to you
%% when you complete the rights form.  These commands have SAMPLE
%% values in them; it is your responsibility as an author to replace
%% the commands and values with those provided to you when you
%% complete the rights form.
\setcopyright{acmlicensed}
\copyrightyear{2018}
\acmYear{2018}
\acmDOI{XXXXXXX.XXXXXXX}

%% These commands are for a PROCEEDINGS abstract or paper.
\acmConference[Conference acronym 'XX]{Make sure to enter the correct
  conference title from your rights confirmation emai}{June 03--05,
  2018}{Woodstock, NY}
%%
%%  Uncomment \acmBooktitle if the title of the proceedings is different
%%  from ``Proceedings of ...''!
%%
%%\acmBooktitle{Woodstock '18: ACM Symposium on Neural Gaze Detection,
%%  June 03--05, 2018, Woodstock, NY}
\acmISBN{978-1-4503-XXXX-X/18/06}


%%
%% Submission ID.
%% Use this when submitting an article to a sponsored event. You'll
%% receive a unique submission ID from the organizers
%% of the event, and this ID should be used as the parameter to this command.
%%\acmSubmissionID{123-A56-BU3}

%%
%% For managing citations, it is recommended to use bibliography
%% files in BibTeX format.
%%
%% You can then either use BibTeX with the ACM-Reference-Format style,
%% or BibLaTeX with the acmnumeric or acmauthoryear sytles, that include
%% support for advanced citation of software artefact from the
%% biblatex-software package, also separately available on CTAN.
%%
%% Look at the sample-*-biblatex.tex files for templates showcasing
%% the biblatex styles.
%%

%%
%% The majority of ACM publications use numbered citations and
%% references.  The command \citestyle{authoryear} switches to the
%% "author year" style.
%%
%% If you are preparing content for an event
%% sponsored by ACM SIGGRAPH, you must use the "author year" style of
%% citations and references.
%% Uncommenting
%% the next command will enable that style.
%%\citestyle{acmauthoryear}


%%
%% end of the preamble, start of the body of the document source.
\begin{document}

%%
%% The "title" command has an optional parameter,
%% allowing the author to define a "short title" to be used in page headers.
\title{The Name of the Title Is Hope}

%%
%% The "author" command and its associated commands are used to define
%% the authors and their affiliations.
%% Of note is the shared affiliation of the first two authors, and the
%% "authornote" and "authornotemark" commands
%% used to denote shared contribution to the research.

\author{Mukesh Tiwari}
\affiliation{%
 \institution{Swansea University}
 \country{United Kingdom}}
 \email{mukesh.tiwari@swansea.ac.uk}

\author{Berry Schoenmakers}
\affiliation{%
  \institution{TU Eindhoven, Eindhoven}
  \country{The Netherlands}}
  \email{l.a.m.schoenmakers@tue.nl}


\author{Bas Spitters}
\affiliation{%
  \institution{Aarhus University}
  \country{Denmark}}
\email{spitters@cs.au.dk}

%%
%% By default, the full list of authors will be used in the page
%% headers. Often, this list is too long, and will overlap
%% other information printed in the page headers. This command allows
%% the author to define a more concise list
%% of authors' names for this purpose.
\renewcommand{\shortauthors}{Tiwari et al.}

%%
%% The abstract is a short summary of the work to be presented in the
%% article.
\begin{abstract}
  Despite the recent growth of zero-knowledge succinct argument 
  of knowledge (ZKSNARK) in cryptocurrencies, 
  sigma protocol remains a popular choice in electronic voting to maintain privacy 
  and verifiability of elections and still used in Helios, Belenois, and SwissPost voting systems. 
  However, the existing implementations of sigma protocol are not formally verified and 
  therefore offer no security guarantees. \textbf{Double check this and its purpose: Moreover, 
  the same code is written twice, once for the front-end and once for the back-end}.
  In this paper, we present a formal verification of sigma protocol in the Coq proof assistant. 
  We prove that our formalisation is (special) sound, complete, and (honest verifier) 
  zero-knowledge. Moreover, 
  we compile our Coq formalisation to WebAssembly code and Rust code, and 
  thereby solve the problem of writing the same code twice, once for the 
  front-end and once for the back-end. We demonstrate the applicability of our
  formalisation by encoding the cryptographic protocols implemented in 
  Helios voting systems. Our long terms goal is to provide a verified
  cryptographic library that can be readily used in 
  privacy-preserving voting systems.


\end{abstract}


\begin{CCSXML}
<ccs2012>
  <concept>
      <concept_id>10002978.10002986.10002990</concept_id>
      <concept_desc>Security and privacy~Logic and verification</concept_desc>
      <concept_significance>500</concept_significance>
      </concept>
</ccs2012>
\end{CCSXML}
  
\ccsdesc[500]{Security and privacy~Logic and verification}

%%
%% Keywords. The author(s) should pick words that accurately describe
%% the work being presented. Separate the keywords with commas.
\keywords{Sigma Protocol, Formal Verification, Coq, Cryptography, Zero-Knowledge Proof}



%%
%% This command processes the author and affiliation and title
%% information and builds the first part of the formatted document.
\maketitle

\section{How to pitch this paper and What is the unique selling point of our work?}
Our Coq formalisation can be used at front-end to generate Web Assembly code and 
Rust code at the back-end. Contrary to the existing work, our formalisation
does not write the same code twice. But sigma protocols are arcane and has 
been formalised couple of times before so why another formalisation?
None of the formalisation has been able to extract the code to executable code 
and one that was able to do so did not reason about probabilities in an intuitive way.
Moreover, that work was just geared towards verifying a transcript rather than
constructing it. Also, recently ZKP community started a movement to 
formalise the Sigma protocols. We also demonstrates the 
applicability of our formalisation by encoding Helios cryptographic protocols
in our formalisation. 




\section{Introduction}
Despite the recent growth and popularity of zero-knowledge succinct 
argument of knowledge (ZKSNARK), sigma protocol remains a
leading cryptographic proof system in privacy-preserving voting systems. 
Sigma protocols are used in Helios, Belenois, and SwissPost voting 
systems (\textbf{Look for more examples}). 
Moreover, recently ZKP community started a movement to standardise
the Sigma protocols. 

One of the main reasons for the popularity of sigma protocols in 
privacy-preserving voting systems is their simplicity and well-understood
security. 
 
Sigma protocols are a special case of
zero-knowledge proofs where the verifier is assumed to be honest. Sigma protocols
allow a prover to convince a verifier that they possess some knowledge without
revealing anything else about the knowledge itself. Sigma protocols are used in

\textbf{Introduce here that sigma protocols are efficient and simple and all 
other details about sigma protocols.} Sigma protocols allow a prover to convince a verifier that 
they possess some knowledge without revealing anything else about the knowledge itself.  
More formally, for a given relation $R$ and a statement $x$, the prover convinces the verifier
that they posses a witness $w$ such that ($x$, $w$) $\in$ $R$. We would like to stress that
Sigma protocols are a special case of zero-knowledge proofs where the verifier is 
assumed to be honest. Sigma protocols were first defined by Ronald Cramer \cite{cramer1996modular} and the 
first efficient sigma protocol was introduced by Schnorr in \cite{schnorr1991efficient}. 
Eventhough there exists many sigma protocols, the Schnorr protocol is one of the most well-known
sigma protocol and is used extensively in privacy-preserving voting systems, e.g, Helios, SwissPost, etc. 
Therefore, our formalisation is geared towards the Schnorr protocol; moreover, we 
also formalise $n$ PARALLEL composition, $n$ AND composition, $n$ OR composition, 
and $n$ EQ composition of Schnorr protocol. We also formalise Okamoto protocol as a subprotocol 
for NEQ composition (\textbf{Berry: does it sound okay?}). However, we have not seen 
much use of Okamoto protocol in the privacy-preserving voting systems, 
at least in the existing voting systems. Ideally, we could have abstracted the sigma protocols and their composition in a generic way,
but we decided to focus on the Schnorr protocol and its composition to ensure a nice APIs in 
Web Assembly and Rust.




There are numerous implementations of Sigma protocols in various languages, 
e.g., Helios is written in Python, Belenois is written in OCaml, and SwissPost is written in Java.
However, there are two main issues with these implementations: (i)  
the same code is written twice 
once for the front-end (JavaScript, TypeScript) and once for the back-end (Python, OCaml, or Java),
especially in privacy-preserving voting systems such as Helios, SwissPost, and 
(ii) none of these implementations offer any formal guarantees about the correctness of the code.
Given the importance of Sigma protocols in privacy-preserving voting systems,
it has been formalised couple of times before  \cite{5552642,butler2019formalisation,10.1145/3319535.3354247}. 
\cite{5552642,butler2019formalisation} are mainly focused on establishing the 
pen-and-paper proofs of Sigma protocols into theorem provers, and not extracting an executable code.
On the other hand, \cite{10.1145/3319535.3354247} exatract an OCaml code from Coq 
formalisation but it is mostly geared towards verifying an Helios election transcript, 
rather than constructing the primitives to conduct an election. Moreover, 
it lacks many primitives and does not reason about probabilities in an intuitive way.


In this paper, we present a formal verification of Sigma protocols in the Coq proof assistant that 
can be used to generate Web Assembly code at the front-end and Rust code at the back-end. 
We use our formalisation to model the cryptographic protocols implemented in Helios voting systems. 





\textbf{We need to explain why formal verification is important in the context of voting systems.}

\begin{itemize}
  \item Explain zero-knowledge proofs (completeness, soundness, zero-knowledge)
  \item Explain sigma protocols (completeness, special-soundness, honest-verifier zero-knowledg) 
  and mention about the Schnorr protocol
  \item Our contribution
  \item Explain the Schnorr protocol
  \item Explain Parallel, And, Eq, Or, and NEQ relations (also explain that 
  most of the formalisation has worked on And and Or relations)
\end{itemize}

Zero-knowledge proofs are a class of cryptographic protocols that allow a
prover to convince a verifier that a statement is true without revealing 
any information about the statement itself. 
Zero-knowledge proofs are possible for all problems in the $NP$ complexity class. 
$NP$ includes problems where a proof of membership can be efficiently 
verified in polynomial time. In NP, a witness (denoted as $w$) is a 
polynomial-length piece of evidence that allows quick
verification (in polynomial time) that a given statement $s$ 
belongs to the language. This verification process can be represented 
using a binary relation $R$ between the set of statements (S) and the 
set of witnesses ($W$), where $(s, w) \in R$ if the witness $w$ 
demonstrates that the statement $s$ is in the language. 



Sigma protocols are a class of cryptographic protocols that are used to prove the 
knowledge of a witness for a given statement. 

They are used in various cryptographic 
applications such as identification, authentication, and zero-knowledge proofs. 
The security of these protocols is based on the hardness of certain mathematical 
problems such as the discrete logarithm problem. Amongst sigma protocols, 
one of the most well-known protocols is the Schnorr protocol. In this 
paper, we present a formal verification of the Schnorr protocol in the
Coq proof assistant. 


\section{Sigma Protocols}

  Explain here the definition of Sigma Protocols and the Schnorr protocol. 

  \subsection{Parallel Composition}
  Explain the parallel composition of sigma protocols.

  \subsection{And Composition}
  Explain the and composition of sigma protocols.

  \subsection{Or Composition}
  Explain the or composition of sigma protocols.

  \subsection{Equality Composition}
  Explain the equality composition of sigma protocols.

  \subsection{Inequality Composition}
  Explain the inequality composition of sigma protocols.

\section{Formal Verification of Sigma Protocols}


\section{Web Assembly and Rust from the Coq Formalisation}
  Bas Spitter


\section{Case Studies}
  We use our formalisation to model the Cryptographic protocols implemented in 
  Helios voting systems. 


\section{Related Work}
  There are three work. Giles Barthe does not extract to executable code, 
  CryptoHol uses law of excluded middle, and thomas haines work is more about 
  verifying a transcript rather than constructing it. Moreover, 
  it does not reason about probabilities in intuitive way. 

\section{Conclusion, Future Work, and Limitations}





%%
%% The next two lines define the bibliography style to be used, and
%% the bibliography file.
\bibliographystyle{ACM-Reference-Format}
\bibliography{reference}


%%
%% If your work has an appendix, this is the place to put it.
%\appendix

\end{document}
\endinput
%%
%% End of file `sample-sigplan.tex'.
